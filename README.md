# fastapi-example-app

Данный репозиторий содержит пример запуска и настройки веб-сервера. В качестве
сервера используется **nginx unit**, в качестве приложения, обслуживаемого
сервером - небольшая программа на Python с использованием фреймворка
**FastAPI**.

## Архитектура

Сервер **nginx unit** взаимодействует с приложением по стандарту
**Asynchronous** **Server** **Gateway** **Interface** **(ASGI)**, являющимся
развитием стандарта **WSGI** и совместимым с ним. Данный стандарт описывает
требования к серверу и приложению, необходимые для их корректного
взаимодействия. Согласно ASGI, приложению необходимо предоставить серверу
единственный вызываемый объект (функцию, класс, etc.), принимающий 2 аргумента,
в свою очередь, серверу необходимо передать 2 вызываемый объекта - один,
позволяющий приложению прочитать поступивший запрос, и второй, позволяющий
приложению сформировать ответ на данный запрос

## Сравнение с CGI

В стеке **nginx** и **PyroCMS** **/** **WordPress** взаимодействие между
веб-сервером и приложением описывается стандартом **CGI** или его
предшественником, протоколом **FastCGI**. По стандарту **CGI** для каждого
HTTP-запроса, предназначенного приложению, сервер должен запускать приложение,
осуществляющее обработку запроса, при этом взаимодействие происходит через
стандартные потоки ввода-вывода. Согласно протоколу **FastCGI**, сервер и
приложение общаются между собой посредством unix-сокета или протокола TCP/IP,
для каждого HTTP-запроса сервер отправляет запрос приложению, при этом
приложение может быть запущено постоянно

По сравнению с **FastCGI**, **ASGI** предполагает, что вызывающий код
веб-сервера также написан на Python, чем похож на **Java Servlet API**, так как
обе технологии описывают взаимодействие сервера и приложения как модулей
программы на конкретном языке программирования.

**nginx unit** реализует (с помощью модулей), набор стандартов стандартов
наподобие **ASGI**, специфичных для различных языков программирования, и
совмещает в себе функциональность веб-сервера и сервера приложений, с одной
стороны, позволяя маршрутизировать запросы в зависимости от запрашиваемого URI,
предоставлять статические файлы, а также осуществлять SSL-терминацию, а с другой
стороны управлять приложением, реализующим бизнес-логику

## Настройки сервера

Поле `"listeners"` позволяет настроить один или несколько адресов на хосте и
сокетов, которые будет слушать **unit**. Поле `"pass"` говорит, куда должен быть
перенаправлен запрос на соответсвующий адрес, пунктом назначения в данном случае
может быть приложение, маршрут или группа серверов

```JSON
"listeners": {
    "*:80": {
        "pass": "routes"
    }
},
```

Поле `"routes"` позволяет настроить маршруты, к которым имеет доступ клиент. В
данном случае, маршруты настроены таким образом, что URI запроса, пришедшего на
адрес `"/"`, будет переписан на `"/docs"`, запросы на остальные адреса
передаются напрямую приложению

```JSON
"routes": [
    {
        "match": {
            "uri": [
                "/"
            ]
        },

        "action": {
            "rewrite": "/docs",
            "pass": "applications/fastapi"
        }
    },

    {
        "action": {
            "pass": "applications/fastapi"
        }
    }
],
```

Поле `"applications"` позволяет настроить одно или несколько приложений, которые
будут запущены сервером, а также содержит конфигурацию, необходимую для запуска
приложения. Для Python серверу необходимо передать путь до приложения, путь
`PYTHONHOME`, содержащий интерпретатор, название модуля приложения, а также имя
переменной в данном модуле, содержащей вызываемый объект, реализующий стандарт
**ASGI**

```JSON
"applications": {
    "fastapi": {
        "type": "python 3.11",
        "path": "/app/fastapi_example_app/",
        "home": "/app/.venv/",
        "module": "asgi",
        "callable": "app"
    }
},
```

В целях отладки также целесообразно включить логгирование маршрутов, установив
значение поля `"log_route"` равное `true`. Для каждого запроса в лог сервера
будет выведен номер или имя маршрута, по которому был перенаправлен запрос

```JSON
"settings": {
    "http": {
        "log_route": true
    }
}
```

**unit** предоставляет администраторам REST API, позволяющий осуществлять
конфигурацию сервера. При этом конфигурация может быть изменена динамически без
перезапуска самого сервера. Например, если конфигурационный файл лежит на
сервере по пути `/config/config.json`, то с помощью следующего PUT-запроса можно
загрузить новую конфигурацию через сокет сервера

```bash
curl -X PUT --data-binary @/config/config.json \
    --unix-socket /var/run/control.unit.sock \
    http://localhost/config
```

Получим ответ

```JSON
{
    "success": "Reconfiguration done."
}
```

## Настройка SSL/TLS

Для настройки SSL необходимо сгенерировать бандл из сертификата и ключа,
сгенерированных, например, OpenSSL и разместить его на сервере

```bash
cat cert.crt key.key > bundle.pem
```

Если бандл был размещен по пути `/ssl/bundle.pem`, то загрузить его можно через
сокет сервера по адресу `/certificates/bundle`.

```bash
curl -X PUT --data-binary @/ssl/bundle.pem --unix-socket \
    /var/run/control.unit.sock \
    http://localhost/certificates/bundle
```

Получим ответ

```JSON
{
    "success": "Certificate chain uploaded."
}
```

Далее необходимо обновить конфигурацию сервера, внести туда добавленный бандл, а
также обновить порт на 443, используемый для HTTPS. Создадим файл `put.json`

```JSON
{
    "*:443": {
        "pass": "routes",
        "tls": {
            "certificate": "bundle"
        }
    }
}
```

Если файл был размещен по пути `/ssl/put.json`, то загрузить его можно по адресу
`/config/listeners/`, API **unit** обновит объект, находящийся по указанному
адресу, при обращении к нему с методом PUT

```bash
curl -X PUT --data-binary @/ssl/put.json \
    --unix-socket /var/run/control.unit.sock \
    http://localhost/config/listeners/
```

Получим ответ

```JSON
{
    "success": "Reconfiguration done."
}
```

## Сборка

```bash
docker build --tag ngunit:latest .
```

## Запуск

При запуске **unit** читает конфигурацию из директории `/docker-entrypoint.d/`

```bash
docker run -d --name unit-example \
    -p 80:80 \
    -p 443:443 \
    -v $(pwd)/unit/:/docker-entrypoint.d/ \
    ngunit:latest
```

Автоматически конфигурация из данной директории применяется только при создании
контейнера, для динамической переконфигурации следует использовать следующую
команду. С помощью **curl** мы передаем конфиг, который вмонтирован внутрь
контейнера, в unix-сокет **unit** по пути `http://localhost/config`

```bash
docker exec -it unit-example \
    curl -X PUT --data-binary @/docker-entrypoint.d/config.json \
        --unix-socket /var/run/control.unit.sock \
        http://localhost/config
```

### Настройка SSL/TLS в Docker

Скопируем бандл с сертификатом и ключом внутрь контейнера

```bash
docker cp ssl/bundle.pem unit-example:/
docker exec -it unit-example \
    curl -X PUT --data-binary @/bundle.pem \
        --unix-socket /var/run/control.unit.sock \
        http://localhost/certificates/bundle
```

Обновим поле `"listeners"` в конфигурации

```bash
docker cp ssl/put.json unit-example:/
docker exec -it unit-example \
    curl -X PUT --data-binary @/put.json \
        --unix-socket /var/run/control.unit.sock \
        http://localhost/config/listeners/
```
